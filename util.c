/****************************************************************************************
 *	Program contains generation of tables, processing of tables and displaying	*
 *	output.								*
 *											*
 *	Tables are generated using the information generated by grammar written in	*
 *	yacc file. Functions are written to analyze those tables and generate		*
 *	required output. The information generated by these functions are stored in     *
 *	proper data structures and display functions are written to view the required   *
 *      information stored in those structures.                                         *
 *****************************************************************************************/

#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include "common.h"
#include "Cbrace_stack.h"

stack_brace cbr_stack; // Stack for handling equal curly braces

func_call_trace temp_call_trace[1024];
int temp_index = 0;
int visited[1024];
int parent_thread_index = -1;

void get_parameter(char var_name[])
{
    par_tab[par_index].func_index = global_func_index;
    strcpy(par_tab[par_index].type,data_type);
    strcpy(par_tab[par_index].par_name,var_name);
    //printf("\n\t\t %s \t %s \t %d",par_tab[par_index].par_name,par_tab[par_index].type,par_tab[par_index].func_index);
    par_index++;
    par_counter++;
}

void get_log_entry(char log_obj[])
{
    local_found = 0;
    for(i = 0;i < symbol_index; i++)
	{
	    if (sym_tab[i].func_index == global_func_index - 1 && strcmp(sym_tab[i].sym_name,log_obj) == 0 && (!extern_flag))
		{
		    local_found = 1;
		    log_tab[log_index].index = log_index;
		    log_tab[log_index].line_number = line_counter;
		    log_tab[log_index].func_index = global_func_index - 1;
		    strcpy(log_tab[log_index].sym_name,log_obj);
		    strcpy(log_tab[log_index].type,"Local");
		    log_index++;
		    return;
		}
	}

    if (!local_found)
	{
	    for(i = 0;i < global_index; i++)
		{
		    if (strcmp(gsym_tab[i].sym_name,log_obj) == 0)
			{
			    log_tab[log_index].index = log_index;
			    log_tab[log_index].line_number = line_counter;
			    log_tab[log_index].func_index = global_func_index - 1;
			    strcpy(log_tab[log_index].sym_name,log_obj);
			    strcpy(log_tab[log_index].type,"Global");
			    //printf("\nGlobal_func_index :%d",global_func_index-1);
			    //printf("\n\t %5d %15s %15s %15s %15d",log_index,func_tab[log_tab[log_index].func_index].func_name,log_tab[log_index].sym_name,log_tab[log_index].type,log_tab[log_index].line_number);
			    log_index++;
			    return;
			}
		}

	}
    temp_call_trace[temp_index].index = temp_index;
    temp_call_trace[temp_index].parent_index = global_func_index - 1;
    strcpy(temp_call_trace[temp_index].func_name,log_obj);
    temp_call_trace[temp_index].line_number = line_counter;
    temp_index++;
}

void generate_tree_head()
{
    int i;
    call_trace_tree *temp_head;

    for (i = 0; i < global_func_index; i++)
	{
	    temp_head = (call_trace_tree *)malloc(sizeof(call_trace_tree));
	    temp_head->index = i;
	    temp_head->func_call_obj.index = i;
	    temp_head->func_call_obj.func_index = i;
	    strcpy(temp_head->func_call_obj.func_name,func_tab[i].func_name);
	    temp_head->func_call_obj.line_number = func_tab[i].line_number;
	    temp_head->next = NULL;

	    stack_trace[i] = temp_head;
	    printf("\n i:%d\t func_id:%d\t fname:%s\t line:%d",stack_trace[i]->index,stack_trace[i]->func_call_obj.func_index, stack_trace[i]->func_call_obj.func_name, stack_trace[i]->func_call_obj.line_number);
	}
}

int generate_trace_tree()
{
    int i, j, k, l;
    call_trace_tree *node, *traverse_node;

    if(call_trace_index != 0)
	{
	    for(i = 0; i < global_func_index; i++)
		{
		    for (j = 0; j < call_trace_index; j++)
			{
			    if (i == call_trace[j].parent_index)
				{
				    for (k = 0; k < semphr_index; k++)
					if (sem_tab[k].sem_wait_point <= call_trace[j].line_number && sem_tab[k].sem_post_point >= call_trace[j].line_number)
					    break;

				    for (l = 0; l < mutex_index; l++)
					if (mutex_tab[l].mutex_lock_point <= call_trace[j].line_number && mutex_tab[l].mutex_unlock_point >= call_trace[j].line_number)
					    break;

				    if (k != semphr_index)
					continue;

				    if (l != mutex_index)
					continue;

				    for (k = 0; k < thread_index; k++)
					{
					    if (thread_tab[k].func_index == call_trace[j].func_index)
						break;
					}
				    if (k != thread_index)
					continue;

				    node = (call_trace_tree *)malloc(sizeof(call_trace_tree));
				    node->index = call_trace[j].func_index;
				    node->func_call_obj = call_trace[j];
				    node->next = NULL;

				    traverse_node = stack_trace[i];
				    while (traverse_node->next != NULL)
					traverse_node = traverse_node->next;

				    traverse_node->next = node;

				}
			}

		}
	    return 1;
	}
    return 0;
}

void init_visited()
{
    int i;

    for (i =0; i < global_func_index; i++)
	{
	    visited[i] = 0;
	}
}


void DFS(call_trace_tree *G[],int i,int visited[])
{
    // VARIABLE DECLARATION
    call_trace_tree *p;
    int j;
    // MAKE STARTING NODE VISITED
    // printf("%s\t",G[i]->vname);
    p=G[i];
    visited[i]=1;
    while(p!=NULL)
	{
	    // MAKE NODES VISITED ACCORDING TO THEIR ADJACENCY
	    i=p->index;
	    if(!visited[i])
		{
		    for (j = 0; j < log_index; j++)
			{
			    if ((strcmp(log_tab[j].type,"Global")) == 0 && log_tab[j].func_index == i)
				{
				    func_cs_tab[func_cs_index].index = func_cs_index;
				    func_cs_tab[func_cs_index].parent_thread_index = parent_thread_index;
				    strcpy(func_cs_tab[func_cs_index].critical_obj, log_tab[j].sym_name);
				    func_cs_tab[func_cs_index].critical_location = log_tab[j].line_number;
				    func_cs_tab[func_cs_index].func_index = i;
				    func_cs_index++;
				}
			}
		    DFS(G,i,visited);
		}

	    p=p->next;
	}
}



void process_func_call()
{
    int i, j;
    int func_call = 0;
    call_trace_tree *p;

    for (i = 0; i < temp_index; i++)
	{
	    for (j = 0; j < global_func_index; j++)
		{
		    if(strcmp(temp_call_trace[i].func_name,func_tab[j].func_name) == 0)
			{
			    call_trace[call_trace_index] = temp_call_trace[i];
			    call_trace[call_trace_index].index = call_trace_index;
			    call_trace[call_trace_index].func_index = j;
			    call_trace_index++;
			    break;
			}
		}

	}
    generate_tree_head();
    func_call = generate_trace_tree();
    printf("\n\n FUNCTION CALL TRACE\n");
    if (func_call)
	{
	    for (i = 0; i < global_func_index; i++)
		{
		    p = stack_trace[i];
		    while(p != NULL)
			{
			    printf(" %d->",p->index);
			    p = p->next;
			}
		    printf("\n");
		}
	    for (i = 0; i < global_func_index; i++)
		{
		    for (j = 0; j < thread_index; j++)
			{
			    if (i == thread_tab[j].func_index)
				{
				    parent_thread_index = i;
				    DFS(stack_trace, i, visited);
				    init_visited();
				}
			}

		}

	}

}



void process_header(char header_text[])
{
    char *hdr_file, substr[5] = "\"";
    int len;

    if ((hdr_file = strstr(header_text,substr)))
	{
	    len = strlen(hdr_file);
	    hdr_file++;
	    hdr_file[len-2] = '\0';
	    headers[hdr_index] =  (char *)malloc(50 * sizeof(char));
	    strcpy(headers[hdr_index],hdr_file);
	    //printf("\n Header file name:%s\n ",headers[hdr_index]);
	    hdr_index++;

	}
}

void extract_archieve(char *file_name)
{
    char *source_path = NULL;
    int i,path_length;

    source_path = (char *)malloc(50 * sizeof(char));
    path_length = strlen(file_name);
    for (i = path_length; i >= 0; i--)
	{
	    if (*(file_name + i) == '/')
		{
		    *(file_name + i + 1) = '\0';
		    break;
		}
	}

    //printf("\n\n Source path:%s",file_name);

}


void get_symbol(char var[])
{
    if (struct_flag || thread_lib_flag)
	return;
    if(flag == 0 || (flag == 1 && extern_flag == 1)) // Global variable entry
	{
	    if (!extern_flag)
		{
		    gsym_tab[global_index].line_number = line_counter;
		    gsym_tab[global_index].index = global_index;
		    strcpy(gsym_tab[global_index].sym_name,var);
		    strcpy(gsym_tab[global_index].access,access);
		    strcpy(gsym_tab[global_index].type,data_type);
		    //printf("\n Access of %s is %s \n line number: %d \nData type:%s",gsym_tab[global_index].sym_name,gsym_tab[global_index].access,gsym_tab[global_index].line_number,gsym_tab[global_index].type);
		    global_index++;
		    //extern_flag = 0;
		}
	}
    else // Local variable entry
	{

	    sym_tab[symbol_index].func_index = func_index-1;
	    sym_tab[symbol_index].index = symbol_index;
	    strcpy(sym_tab[symbol_index].access,access);
	    strcpy(sym_tab[symbol_index].sym_name,var);
	    strcpy(sym_tab[symbol_index].type,data_type);
	    sym_tab[symbol_index].line_number = line_counter;

	    symbol_index++;
	}

}

void find_join_obj(char thread_obj[])
{
    int i;

    for (i = 0; i < thread_index; i++)
	{
	    if (strcmp(thread_tab[i].thread_obj, thread_obj) == 0)
		{
		    thread_tab[i].pthread_join = line_counter;
		    break;
		}
	}
}
void update_log_tab(int copy_log_index[], int copy_index, int thread_id)
{
    int i;
    for (i = 0; i < copy_index; i++)
	{
	    log_tab[log_index] = log_tab[copy_log_index[i]];
	    log_tab[log_index].thread_index = thread_id;
	    log_index++;
	}
}

void find_log_entries(int func_index, int thread_id)
{
    int i;
    int copy_log_index[50], copy_index = 0;


    for(i = 0; i < log_index; i++)
	{
	    if (log_tab[i].func_index == func_index)
		{
		    copy_log_index[copy_index] = i;
		    copy_index++;
		}
	}
    update_log_tab(copy_log_index,copy_index, thread_id);
}

void check_threads()
{
    int i, j;
    for (i = 0; i < thread_index; i++)
	{
	    for(j = 0; j < thread_log_index; j++)
		{
		    if (thread_log_tab[j].func_index == thread_tab[i].func_index)
			break;
		}
	    if (j == thread_log_index)
		{
		    thread_log_tab[thread_log_index].func_index = thread_tab[i].func_index;
		    thread_log_index++;
		}
	    else
		find_log_entries(thread_tab[i].func_index, thread_tab[i].index );
	}
}


void assign_func_index()
{
    int i, j;

    if (thread_index == 0)
	{
	    printf("\n\n NO THREAD FUNCTIONS FOUND!!!");
	    exit(0);
	}
    for (i = 0; i < thread_index; i++)
	for (j = 0; j < global_func_index; j++)
	    if (strcmp(thread_tab[i].func_name,func_tab[j].func_name) == 0)
		{
		    thread_tab[i].func_index = func_tab[j].index;
		    break;
		}
}


void check_thread_entry()
{
    int i, j;

    for (i = 0; i < log_index; i++)
	{
	    for(j = 0; j < thread_index; j++)
		{
		    if (log_tab[i].func_index == thread_tab[j].func_index)
			{
			    log_tab[i].thread_func = 1;
			    log_tab[i].thread_index = thread_tab[j].index;
			    break;
			}
		}
	    if(j == thread_index)
		{
		    log_tab[i].thread_func = 0;
		    log_tab[i].thread_index = -1;
		}
	}
}


void create_main_thread()
{
    int i;

    for (i = 0; i < global_func_index; i++)
	if (strcmp(func_tab[i].func_name,"main") == 0)
	    {
		thread_tab[thread_index].index = thread_index;
		strcpy(thread_tab[thread_index].thread_obj,"main");
		strcpy(thread_tab[thread_index].func_name,"main");
		thread_tab[thread_index].func_index = i;
		strcpy(thread_tab[thread_index].thread_attr,"NULL");
		strcpy(thread_tab[thread_index].func_arg,"NULL");
		strcpy(thread_tab[thread_index].parent_thread,"main");
		thread_index++;
	    }
}


int check_synchro_join(int log_index)
{
    int i;

    for (i = 0; i < thread_index; i++)
	{
	    if (thread_tab[i].pthread_join == 0)
		break;
	    if (thread_tab[i].pthread_join > log_tab[log_index].line_number)
		break;

	}
    if (i == thread_index)
	return 1;

    return 0;
}

// Function detects critical region
void cs_check()
{
    int i, j, k, l;
    int detect_join;

    for (i = 0; i < log_index; i++)
	{
	    //	printf("but now here..");
	    cs_detect = 0;
	    if (!log_tab[i].thread_func)
		continue;
	    /* check for main thread. Shared object used in main thread
	       creates no race if used before thread creation or after
	       thread join. */
	    /*	if (strcmp(thread_tab[log_tab[i].thread_index].func_name,"main") == 0)
		{
		for (k = 0; k < thread_index; k++)
		{

		printf("\n Thread index:%d\nShared object Line no.:%d",k,log_tab[i].line_number);
		if (thread_tab[k].index == log_tab[i].thread_index)
		continue;
		printf("\nThread Creation Line No:%d\n Thread Join Line No.:%d",thread_tab[k].line_number,thread_tab[k].pthread_join);
		if (thread_tab[k].line_number < log_tab[i].line_number && thread_tab[k].pthread_join > log_tab[i].line_number)
		break;
		}
		//detect_join = check_synchro_join(i);

		printf("\nthred_index %d and k %d",thread_index,k);
		if (k == thread_index)
		cs_detect = 1;
		}

		if (cs_detect)
		{
		printf("I was here...");
		continue;
		}

	    */cs_detect = 0;
	    // loop used to handle proper locks
	    for (k = 0; k < semphr_index; k++)
		if (sem_tab[k].sem_wait_point <= log_tab[i].line_number && sem_tab[k].sem_post_point >= log_tab[i].line_number)
		    break;

	    for (l = 0; l < mutex_index; l++)
		if (mutex_tab[l].mutex_lock_point <= log_tab[j].line_number && mutex_tab[l].mutex_unlock_point >= log_tab[j].line_number)
		    break;

	    if (k != semphr_index)
		continue;

	    if (l != mutex_index)
		continue;


	    if ( (log_tab[i].thread_func) && strcmp(log_tab[i].type,"Global") == 0)
		{
		    for (j= i + 1; j < log_index; j++)
			{
			    if ( (log_tab[j].thread_func) && log_tab[i].thread_index != log_tab[j].thread_index  && strcmp(log_tab[j].type,"Global") == 0 && strcmp(log_tab[i].sym_name,log_tab[j].sym_name) == 0)
				{
				    for (k = 0; k < semphr_index; k++)
					if (sem_tab[k].sem_wait_point <= log_tab[j].line_number && sem_tab[k].sem_post_point >= log_tab[j].line_number)
					    break;

				    for (l = 0; l < mutex_index; l++)
					if (mutex_tab[l].mutex_lock_point <= log_tab[j].line_number && mutex_tab[l].mutex_unlock_point >= log_tab[j].line_number)
					    break;

				    if (k != semphr_index)
					continue;

				    if (l != mutex_index)
					continue;

				    cs_detect = 1;
				    // code for inserting shared object in critical section
				    for (k = 0; k < cs_index; k++)
					{
					    if (log_tab[i].line_number == cs_tab[k].critical_location && strcmp(log_tab[i].sym_name,cs_tab[k].critical_obj) == 0)
						break;
					}
				    if (k == cs_index)
					{
					    cs_tab[cs_index].index = cs_index;
					    strcpy(cs_tab[cs_index].critical_obj, log_tab[i].sym_name);
					    cs_tab[cs_index].thread_func_index = log_tab[i].func_index;
					    cs_tab[cs_index].critical_location = log_tab[i].line_number;
					    cs_index++;
					}

				    for (k = 0;k < cs_index; k++)
					{
					    if (log_tab[j].line_number == cs_tab[k].critical_location && strcmp(log_tab[j].sym_name,cs_tab[k].critical_obj) == 0)
						break;
					}
				    if (k == cs_index)
					{

					    cs_tab[cs_index].index = cs_index;
					    strcpy(cs_tab[cs_index].critical_obj, log_tab[j].sym_name);
					    cs_tab[cs_index].thread_func_index = log_tab[j].func_index;
					    cs_tab[cs_index].critical_location = log_tab[j].line_number;
					    cs_index++;
					}

				}
			}
		    if (cs_detect)
			{

			}
		}
	}

}


void display_global_variables()
{
    int i;
    if (global_index != 0)
	{
	    printf("\n\n\t\t\t    = = = GLOBAL SYMBOL's TABLE = = =\n");
	    // printf("\t_________________________________________________________________________");
	    printf("\n\t %5s %15s %15s %15s %15s","INDEX","ACCESS","NAME","TYPE","LINE\n");
	    printf("\t_________________________________________________________________________\n\n");
	    for(i = 0; i < global_index; i++)
		printf("\t %5d %15s %15s %15s %15d\n",gsym_tab[i].index,gsym_tab[i].access,gsym_tab[i].sym_name,gsym_tab[i].type,gsym_tab[i].line_number);
	    printf("\t_________________________________________________________________________\n");
	}

}

void display_function()
{
    int i;
    if (global_func_index != 0)
	{
	    printf("\n\n\t\t\t   = = = USER DEFINED FUNCTIONS = = = \n");
	    // printf("\t_________________________________________________________________________\n");
	    printf("\n\t %5s %15s %15s %15s %15s","INDEX","LINE","NAME","RET_TYPE","PARMTRS\n");
	    printf("\t_________________________________________________________________________\n\n");
	    for(i = 0; i < global_func_index; i++)
		printf("\t %5d %15d %15s %15s %15d\n ",func_tab[i].index,func_tab[i].line_number,func_tab[i].func_name,func_tab[i].return_type,func_tab[i].no_of_parameter);
	    printf("\t_________________________________________________________________________\n");
	}
}

void display_local_variables()
{
    int i;

    if (symbol_index != 0)
	{
	    printf("\n\n\t\t\t\t  = = = LOCAL SYMBOL's TABLE = = = \n");
	    printf("\n\t %5s %15s %15s %15s %15s %15s","INDEX","ACCESS","NAME","TYPE","FUNC_INDEX","LINE\n");
	    printf("\t___________________________________________________________________________________________\n\n");
	    for(i = 0;i < symbol_index; i++)
		printf("\t %5d %15s %15s %15s %15d %15d\n",i,sym_tab[i].access,sym_tab[i].sym_name,sym_tab[i].type,sym_tab[i].func_index,sym_tab[i].line_number);
	    printf("\t___________________________________________________________________________________________\n");

	}
}

void display_func_paramtr()
{
    int i;
    if(par_index != 0)
	{
	    printf("\n\n\t\t\t  = = = FUNCTION's PARAMETER TABLE = = = \n");
	    printf("\n\t %5s %15s %15s %15s","INDEX","NAME","TYPE","\tFUNC_INDEX\n");
	    printf("\t_________________________________________________________________________\n\n");
	    for(i = 0;i < par_index; i++)
		printf("\t %5d %15s %15s %15d\n",i,par_tab[i].par_name,par_tab[i].type,par_tab[i].func_index);
	    printf("\t_________________________________________________________________________\n");
	}
}

void display_thread()
{
    int i;
    if (thread_index != 0)
	{
	    printf("\n\n\t\t\t\t\t     = = = THREAD TABLE = = = \n");
	    printf("\n\t %5s %15s %15s %15s %15s %15s %15s","INDEX","THREAD_OBJ","FUNCTION_NAME","FUNC_INDEX","THREAD_ATTR","FUNC_ARG","PARENT_THREAD\n");
	    printf("\t____________________________________________________________________________________________________________\n\n");
	    for(i = 0;i < thread_index; i++)
		printf("\t %5d %15s %15s %15d %15s %15s %15s\n",i,thread_tab[i].thread_obj,thread_tab[i].func_name,thread_tab[i].func_index,thread_tab[i].thread_attr,thread_tab[i].func_arg,thread_tab[i].parent_thread);
	    printf("\t____________________________________________________________________________________________________________\n");
	}
}

void display_log()
{
    int i;
    if (log_index != 0)
	{
	    printf("\n\n\t\t\t\t\t\t= = = LOG TABLE = = = \n");
	    printf("\n\t %5s %15s %15s %15s %15s %15s %15s","INDEX","FUNCTION_NAME","SYMBOL","TYPE","LINE_NUMBER","THREAD_FUNC","THREAD_INDEX\n");
	    printf("\t____________________________________________________________________________________________________________\n\n");
	    for(i = 0;i < log_index; i++)
		printf("\t %5d %15s %15s %15s %15d %15d %15d\n",i,func_tab[log_tab[i].func_index].func_name,log_tab[i].sym_name,log_tab[i].type,log_tab[i].line_number, log_tab[i].thread_func, log_tab[i].thread_index);
	    printf("\t____________________________________________________________________________________________________________\n");
	}
}

void display_semaphr()
{
    int i;
    if (semphr_index != 0)
	{
	    printf("\n\n\t\t\t = = = Semaphore Table = = = \n");
	    printf("\n\t %5s %15s %15s %15s","INDEX","SEM_OBJECT","WAIT_POINT","POST_POINT\n");
	    printf("\t_________________________________________________________________________\n\n");
	    for(i = 0;i < semphr_index; i++)
		printf("\t %5d %15s %15d %15d\n",i,sem_tab[i].sem_obj,sem_tab[i].sem_wait_point,sem_tab[i].sem_post_point);
	    printf("\t_________________________________________________________________________\n");
	}
}

void display_mutex()
{
    int i;
    if (mutex_index != 0)
	{
	    printf("\n\n\t\t\t = = = Mutex Table = = = \n");
	    printf("\n\t %5s %15s %15s %15s","INDEX","MUTEX_OBJECT","MUTEX_LOCK_POINT","MUTEX_UNLOCK_POINT\n");
	    printf("\t_________________________________________________________________________\n\n");
	    for(i = 0;i < mutex_index; i++)
		printf("\t %5d %15s %15d %15d\n",i,mutex_tab[i].mutex_obj,mutex_tab[i].mutex_lock_point,mutex_tab[i].mutex_unlock_point);
	    printf("\t_________________________________________________________________________\n");
	}
    else
	printf("\n\n No MUTEX entry found for given input");
}

void display_call_trace()
{
    int i;
    if (call_trace_index != 0)
	{
	    printf("\n\n\t\t\t = = = Function Call Trace Table = = = \n");
	    printf("\n\t %5s %15s %15s %15s %15s","INDEX","FUNC_INDEX","FUNC_NAME","PAR_FUNC_NAME","LINE_NUMBER\n");
	    printf("\t_________________________________________________________________________\n\n");
	    for(i = 0;i < call_trace_index; i++)
		printf("\t %5d %15d %15s %15s %15d\n",i,call_trace[i].func_index,call_trace[i].func_name,func_tab[call_trace[i].parent_index].func_name,call_trace[i].line_number);
	    printf("\t_________________________________________________________________________\n");
	}
    else
	printf("\n\n No Function call entry found for given input");
}


int display_critical_section()
{
    //int i;
    int i, j, k = 0 ,flag = 0 ,l = 0 ;
    int similar[10];
    critical_section_unique cs_tab1[10];
    if (cs_index != 0)
	{
	    /* printf("\n\n\t\t\t = = = SUSPECTED CRITICAL SECTION = = = \n");
	       printf("\t_________________________________________________________________________\n");
	       //	printf("\n\t %5s %15s %15s %15s","INDEX","CRITICAL_OBJECT","THREAD_FUNC_INDEX","CRITICAL_LOCATION");
	       for(i = 0;i < cs_index; i++)
	       printf("\n\t\t INDEX: %20d \n\t\t Shared Object: %16s \n\t\t Thread Function Index:  %3d \n\t\t Thread Function: %26s \n\t\t Critical Location:  %8d \n\n\t\t________________________________________________\n",i,cs_tab[i].critical_obj,cs_tab[i].thread_func_index,thread_tab[cs_tab[i].thread_func_index].func_name,cs_tab[i].critical_location);
	       printf("\t_________________________________________________________________________\n");
	    */
	    return 1;
	}
    else
	printf("\n\n NO CRITICAL SECTION DETECTED");
    return 0;
}


void create_cs_log()
{
    int i, j = 0, k = 0, flag = 0, l = 0, min=0, m=0, flag1=1 ;
    int similar[10],min_line , max_line ;

    if ( cs_index == 0 )
	printf("\n\nNO CRITICAL SECTION FOUND!!!\n\n");
    else
	{
	    /* printf("\n\t\t\t\t\t= = = CRITICAL SECTION LOG = = =\n\n\t  INDEX     SHARED OBJECT    THREAD FUNCION INDEX   LOCATION(MIN)    LOCATION(MAX)     THREAD FUNCTION");
	       printf("\n\t________________________________________________________________________________________________________\n\n");
	    */
	    cs_tab1[k].min_critical_location = cs_tab1[k].max_critical_location = cs_tab[j].critical_location ;

	    for(i=0; i < cs_index-1; i++)
		{
		    flag1=1;

		    for(j= i + 1 ; j < cs_index; j++)
			{
			    if( cs_tab[i].thread_func_index == cs_tab[j].thread_func_index &&
				strcmp ( cs_tab[i].critical_obj, cs_tab[j].critical_obj ) == 0 &&
				strcmp ( thread_tab [cs_tab[i].thread_func_index].func_name, thread_tab[cs_tab[j].thread_func_index].func_name ) ==0 )
				{
				    flag = 1 ;
				    flag1 = 0;
				    min = j ;
				    /*for(m=0; m < k; m++)
				      if(cs_tab1[m].thread_func_index == cs_tab[j].thread_func_index && strcmp( cs_tab1[m].critical_obj, cs_tab[j].critical_obj) == 0 && strcmp ( thread_tab [cs_tab1[m].thread_func_index].func_name, thread_tab[cs_tab[j].thread_func_index].func_name ) == 0 )
				      flag=0;    */
				}
			    for(m=0; m < k; m++)
				if(cs_tab1[m].thread_func_index == cs_tab[i].thread_func_index && strcmp( cs_tab1[m].critical_obj, cs_tab[i].critical_obj) == 0 && strcmp ( thread_tab [cs_tab1[m].thread_func_index].func_name, thread_tab[cs_tab[i].thread_func_index].func_name ) == 0 )
				    {
					flag1=0;
					flag=0;
				    }
			}

		    if(flag1 == 1 && j == cs_index)
			{
			    cs_tab1[k].index = k ;
			    strcpy( cs_tab1[k].critical_obj, cs_tab[i].critical_obj ) ;
			    cs_tab1[k].thread_func_index = cs_tab[i].thread_func_index ;
			    cs_tab1[k].min_critical_location = cs_tab[i].critical_location;
			    cs_tab1[k].max_critical_location = cs_tab[i].critical_location;
			    k++ ;
			    flag1=0;
			}
		    if(flag == 1)
			{
			    cs_tab1[k].index = k ;
			    strcpy( cs_tab1[k].critical_obj, cs_tab[min].critical_obj ) ;
			    cs_tab1[k].thread_func_index = cs_tab[min].thread_func_index ;
			    cs_tab1[k].min_critical_location = cs_tab[i].critical_location;
			    cs_tab1[k].max_critical_location = cs_tab[min].critical_location;
			    k++ ;
			    flag = 0;
			}
		} //for i


	    /*       for(i=0; i<k; i++)
		     printf("\t    %d\t\t    %s\t\t%d\t\t    %d\t\t\t%d\t\t\t%s\n",cs_tab1[i].index, cs_tab1[i].critical_obj, cs_tab1[i].thread_func_index, cs_tab1[i].min_critical_location, cs_tab1[i].max_critical_location, thread_tab[cs_tab1[i].thread_func_index].func_name );
		     printf("\t_________________________________________________________________________________________________________\n");
	    */
	} //ELSE
}

void print_func_cs(int cs_index)
{
    int i;

    for (i = 0; i < func_cs_index; i++)
	{
	    if (func_cs_tab[i].parent_thread_index == cs_index)
		{
		    printf("\n\n\t\t\t = = = SUSPECTED CRITICAL SECTION AFFECTED BY THREAD : %s= = = \n",thread_tab[cs_tab1[cs_index].thread_func_index].func_name);
		    printf("\t_________________________________________________________________________\n");
		    //	printf("\n\t %5s %15s %15s %15s","INDEX","CRITICAL_OBJECT","THREAD_FUNC_INDEX","CRITICAL_LOCATION");
		   printf("\n\t\t INDEX: %20d \n\t\t Shared Object: %16s \n\t\t Parent Thread Index:  %3d \n\t\t  Function Name: %26s \n\t\t Critical Location:  %8d \n\n\t\t________________________________________________\n",i,func_cs_tab[i].critical_obj,func_cs_tab[i].parent_thread_index,func_tab[func_cs_tab[i].func_index].func_name,func_cs_tab[i].critical_location);
		    printf("\t_________________________________________________________________________\n");
		}
	}
}


/*ADDING LOCKS AND UNLOCKS*/
void add_lock_unlock(char *source_file_name,int preprocess_counter )
{
    char s[50], ch, dest_file_name[30]="cscheck_program.c";
    int index_count = 1,flag = 0;
    char sem_waitp[] = "\t //*** Insert synchronization mechanism here (by cs_check tool)";
    char sem_postp[] = "\t //*** Insert synchronization mechanism here (by cs_check tool)";
    FILE * output_file,*add_lock;
    int cs_tab_count = 0;
    char * line;
    ssize_t read;
    size_t len = 0;
    //printf("\n In add_lock %s source file name ",source_file_name);
    getchar();
    output_file = fopen( source_file_name, "r" );
    if(output_file == NULL)
	{
	    printf("\n Error in reading input source file '%s'",source_file_name);
	    return ;

	}
    else
	{
	    add_lock = fopen("temp_cs.c","w");
	    if(add_lock == NULL) {
		printf("\nCan't Create output file ");
		return ;
	    }
	    else {
		//printf("\n Pre counter %d \n cs_tab %d",preprocess_counter,cs_tab1[1].min_critical_location);
		printf("\n\t________________________________________________________________________________\n");
		printf("\n\t	Displaying Suspected Critical Section \n");
		printf("\n\t________________________________________________________________________________\n");
		while (( read = getline(&line,&len,output_file)) != -1) {
		    //printf("\n %d %s \n",index_count,line);
		    index_count++;
		    // inserting
		    if (index_count == cs_tab1[cs_tab_count].min_critical_location) {
			printf("\n\t Index:\t   %d",cs_tab1[cs_tab_count].index);
			printf("\n\t Shared Object:   %s",cs_tab1[cs_tab_count].critical_obj);
			printf("\n\t Thread Function Index : %d",cs_tab1[cs_tab_count].thread_func_index);
			printf("\n\t Starting location for critical section : %d",cs_tab1[cs_tab_count].min_critical_location);
			printf("\n\t Ending location for critical section : %d",cs_tab1[cs_tab_count].max_critical_location);
			printf("\n\t________________________________________________________________________________\n");
			getchar();
			print_func_cs(cs_tab_count);
			printf("\n\t\t Printing actual critical section block");
			printf("\n\t--------------------------------------------------------------------------------\n");
			printf("\n\t Line Number \t Statement ");
			printf("\n\t--------------------------------------------------------------------------------\n");
			//printing to output file
			fprintf(add_lock,"%s",line);
			fprintf(add_lock,"%s \n",sem_waitp);
			flag  = 1;
			continue;
		    }
		    if(flag == 1) {
			printf("\t %d %s ",index_count-1,line);
		    }
		    if(index_count-1 == cs_tab1[cs_tab_count].max_critical_location) {
			printf("\n\t--------------------------------------------------------------------------------\n");
			printf("\n\t________________________________________________________________________________\n");
			fprintf(add_lock," %s ",line);
			fprintf(add_lock,"%s \n",sem_postp);

			cs_tab_count++;
			flag = 0;
			continue;
		    }
		    fprintf(add_lock," %s ",line);
		}
	    }
	}
    fclose(output_file);
    fclose(add_lock);
    //printf("\n\n Press 1 for suggestion of sychronization for above critical section \n");
    //scanf("%d",&display_lock);
    //if(display_lock == 1) {
    printf("\n Creating new file..... ");
    printf("\n File 'temp_cs.c' is created successfully and now displaying it ");
    getchar();
    system("less temp_cs.c");

    //}/
}


void display_help()
{
    printf("\n\n NAME \n\t CRITICAL SECTION DETECTION - An application to automatically detect critical section in multithreaded environment.");
    printf("\n\n DISCRIPTION \n\t To design a GCC extension to identify the critical sections in multithreaded programs that lacks synchronization, which currently is not a feature in GCC (GNU Compiler Collection). The idea behind this technique is that compiler will automatically take care of the critical section by introducing Lock and Unlock function calls in a multithreaded program without involvement of the programmer.");

    printf("\n\n COMMAND LINE OPTIONS \n\t\t -h \t --help prints the usage for tool executable and exits.");
    printf("\n\t\t -a \t prints all tables with critical section(if any).");
    printf("\n\t\t -g \t prints global variable table ");
    printf("\n\t\t -f \t prints function table containing information about user defined functions.");
    printf("\n\t\t -L \t prints log information of variables used in funtions.");
    printf("\n\t\t -l \t printf local variable table.");
    printf("\n\t\t -t \t prints thread tablecontaining thread entries.");
    printf("\n\t\t -c \t prints critical section(if any)");
    printf("\n\t\t -p \t prints paarameter table containing all parameters defined in user defined functions.");
    printf("\n\t\t -s \t prints semaphore table.");
    printf("\n\t\t -m \t prints mutex table.");
    printf("\n\t\t -C \t prints Critical Section Region.");
    printf("\n\t\t -T \t prints function call trace.");
}
